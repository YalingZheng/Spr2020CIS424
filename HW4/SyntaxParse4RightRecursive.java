
public class SyntaxParser4RightRecursive {

	/**
	 * Syntax rule is S - > S + <EXPR>
	 *                <EXPR> -> <INT_LITERAL> * <INT_LITERAL>
	 */
	private laver2 la;
	//private String inputstr;

	public SyntaxParser4RightRecursive(laver2 la) {
		this.la = la;
		//this.inputstr = inputs;
	}
	
	/*
	 * S
	 * parses strings in the language generated by the rule:
	 * S -> <EXPR> ; S | epsilon
	 * */
	public void S() {
		// in the format of S-> <EXPR> ;  S | epsilon
		// read next token
		System.out.println("parse " + la.getInputString());
		System.out.println("ENTER S-> <EXPR> ; S | epsilon");
		int beforeindex = la.getCurrentIndex();
		la.computeNextToken();
		if (la.getNextToken().equals("INT_LITERAL")) {			
				la.clearMemory();
				la.setCurrentIndex(beforeindex);
				EXPR();		
				la.clearMemory();
				la.computeNextToken();
				if (la.getNextToken().equals("SEMICOLON")) {
					// expect next one is 
					if (la.getCurrentIndex() >= la.getEndIndex()-1) {
						System.out.println("Syntax analysis SUCCEED! ");
					}
					else {
						la.clearMemory();
						S();
					}		
				}
				else {
					System.out.println("input rejected by the parser - Lexeme " + la.getNextLexeme() + " not an SEMICOLON");
				}
		} else if (la.getNextToken().equals("")) {
			// expect next one is 
			if (la.getCurrentIndex() >= la.getEndIndex()-1) {
				System.out.println("Syntax analysis SUCCEED! ");
			}
			else {
					System.out.println("Syntax error at index " + la.getCurrentIndex() );
			}		
		}
		else {
			System.out.println("input rejected by the parser - Lexeme " + la.getNextLexeme() + " not an <INT_LITERAL> or SEMICOLON");
		}
		System.out.println("EXIT S-> <EXPR> ; S | epsilon \n");

	}
	
	/*
	 * EXPR
	 * parses strings in the language generated by the rule:
	 * <EXPR> -> <INT_LITERAL> * <INT_LITERAL>
	 * */
	
	public void EXPR() {
		System.out.println("Enter <EXPR> -> <INT_LITERAL> * <INT_LITERAL>");
		la.computeNextToken();
		if (la.getNextToken().equals("INT_LITERAL")) {
			la.clearMemory();
			la.computeNextToken();
			if (la.getNextToken().equals("MULTI_OP")) {
				la.clearMemory();
				la.computeNextToken();
				//System.out.println(la.getNextToken());
				if (la.getNextToken().equals("INT_LITERAL")) {
					// make sure it is the end
					//System.out.println(la.getCurrentIndex() + " " + la.getEndIndex());
					if (la.getCurrentIndex() >= la.getEndIndex()-1) {
						System.out.println("Syntax analysis SUCCEED! ");
					}
					else {
						return;
					}
						
				}
				else {
					System.out.println("Syntax error at index " + la.getCurrentIndex()  );
				}
			} else {
				System.out.println("input rejected by the parser - Lexeme " + la.getNextLexeme() + " not an ASSIGN_OP");
				
			}
		} else {
			System.out.println("input rejected by the parser - Lexeme " + la.getNextLexeme() + " not an INDENTIFIER");			
		}
		System.out.println("EXIT <EXPR> -> <INT_LITERAL> * <INT_LITERAL>");
	}
}
