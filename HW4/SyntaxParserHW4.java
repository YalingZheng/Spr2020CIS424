/**
 * HW4, Task 6
 * STEP 1 - Write a non left-recursive, and passing pairwise disjoint test BNF, which is 
 *  <EXPR> -> <TERM> <EXPR_prime> 
 *  <EXPR_prime> -> (+|-) <TERM> <EXPR_PRIME> | epsilon 
 *  <TERM> -> <FACTOR> <TERM_prime> 
 *  <TERM_prime> --> [*|/] <TERM> <TERM_prime> |  epsilon 
 *  <FACTOR> -> <ID> | <INT_CONSTANT> | ( <EXPR> )
 *  
 * STEP 2 - All the syntax rules map to methods
 * 
 * **/

public class SyntaxParserHW4 {

	private laverHW4 la;

	public SyntaxParserHW4(laverHW4 la) {
		this.la = la;
	}

	/**
	 * Syntax rule is <EXPR> -> <TERM> <EXPR_prime> 
	 * it is non-left recursive and pass the pairwise disjoint test
	 * 
	 *  */
	public void EXPR() {
		System.out.println("ENTER <EXPR> -> <TERM><EXPR_prime>\n");
		TERM();
		EXPR_prime();
		// it is expected to be no more tokens after it
		// if there are more tokens, reject the input
		// otherwise accept the input
		if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
			System.out.println("Input accepted. \n");
		} 
		else {
			la.clearMemory();
			la.computeNextToken();
			//System.out.println("next token is  " + la.getNextToken());
			if (la.getNextToken().equals("")) {
				if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
					System.out.println("Input accepted. \n");
				} else {
					System.out.println("Input rejected. \n");
				}
			}			
		}
		// expect last element to be empty
		System.out.println("EXIT <EXPR> --> <TERM><EXPR_prime>\n");
	}
	
	/* <EXPR_prime> -> (+|-) <TERM> <EXPR_PRIME> | epsilon 
	 * it is non-left recursive, and pass the pairwise disjoint test
	 * */
	public void EXPR_prime() {
		// Is it the end of the input?
		System.out.println("current index " + la.getCurrentIndex() + " end index is " + la.getEndIndex());
		if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
			return;	
			// the end has been reached, do nothing 
		} 
		System.out.println("ENTER <EXPR_prime> -> (+|-) <TERM> <EXPR_prime> | epsilon \n");
		int beforeindex = la.getCurrentIndex();
		// get Next Token
		la.clearMemory();
		la.computeNextToken();		
		// if an addition or subtraction operator is met
		if ((la.getNextToken().equals("ADD_OP")) || (la.getNextToken().equals("SUB_OP"))) {
			// next call should be EXPR()	
			//System.out.println("next token is ADD_OP or SUB_OP");
			TERM();
			EXPR_prime();
			// should be epsilon here
			// Is it the end of the input?
		} else {
			// Is it the end of the input?
			if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
				// the end has been reached, do nothing 
			} 
			else {
				System.out.println("Is next token epsilon? ");
				if (!la.getNextToken().equals("")) {
					System.out.println("next token is not epsilon");
					la.setCurrentIndex(beforeindex);
				}			
				else System.out.println("next token is epsilon");
			}
		}
		// Exit the main call
		System.out.println("EXIT <EXPR_prime> -> (+|-) <EXPR> <EXPR_prime> | epsilon \n");
	}

	/*
	 * TERM parses strings in the language generated by the rule: 
	 * <TERM> -> <FACTOR> <TERM_prime> 
	 */
	
	public void TERM() {
		System.out.println("ENTER <TERM> -> <FACTOR> <TERM_prime> \n");
		FACTOR();
		TERM_prime();		
		// expect last element to be empty
		System.out.println("EXIT <TERM> -> <FACTOR> <TERM_prime> \n");
		
	}
	
	/*  <TERM_prime> --> [*|/] <TERM> <TERM_prime> |  epsilon */

	public void TERM_prime() {
		if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
			return;	
			// the end has been reached, do nothing 
		} 
		System.out.println("ENTER <TERM_prime> --> [*|/] <TERM> <EXPR_prime> |  epsilon\n");
		int beforeindex = la.getCurrentIndex();
		la.clearMemory();
		la.computeNextToken();
		if ((la.getNextToken().equals("MUL_OP")) || (la.getNextToken().equals("DIV_OP"))) {
			// DO SOMETHING HERE
			//System.out.println("Next token is MUL_OP or DIV_OP");
			TERM();
			TERM_prime();
		} else {
			// Is it the end of the input?
				if (la.getCurrentIndex() >= la.getEndIndex() - 1) {
					// the end has been reached, do nothing 
				} 
				else {
					System.out.println("Is next token epsilon? ");
					if (!la.getNextToken().equals("")) {
						System.out.println("next token is not epsilon");
						la.setCurrentIndex(beforeindex);
					}			
					else System.out.println("next token is epsilon");
				}
		}
		System.out.println("EXIT <TERM_prime> --> [*|/] <TERM> <TERM_prime> |  epsilon \n");
	}

	/*
	 * FACTOR parses strings in the language generated by the rule: 
	 * <FACTOR> -> <ID> | <INT_CONSTANT> | ( <EXPR> )
	 */
	public void FACTOR() {
		System.out.println("ENTER <FACTOR> -> <ID> | <INT_CONSTANT> | ( <EXPR> )\n");
		la.clearMemory();
		la.computeNextToken();
		if (la.getNextToken().equals("IDENTIFIER") || la.getNextToken().equals("INT_CONSTANT")) {
			//System.out.println("Next token is IDENTIFIER or INT_CONSTANT");
			// is it the end of 
		} else if (la.getNextToken().equals("LEFT_PAREN")) {
			EXPR();
			la.clearMemory();
			la.computeNextToken();
			if (la.getNextToken().contentEquals("RIGHT_PAREN")) {
				//System.out.println("Next Token is RIGHT_PAREN");
			}
		} 
		
		System.out.println("EXIT <FACTOR> -> <ID> | <INT_CONSTANT> | ( <EXPR> )\n");
	}

}
